<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ASIP Designer Processor Modeling</title>
      <link href="/2025/07/02/asip_design_tool/asip_training_processor_modeling/"/>
      <url>/2025/07/02/asip_design_tool/asip_training_processor_modeling/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><h2 id="Why-and-How-to-Design-an-ASIP"><a href="#Why-and-How-to-Design-an-ASIP" class="headerlink" title="Why and How to Design an ASIP?"></a>Why and How to Design an ASIP?</h2><p>Application-Specific Instruction-set Processors (ASIPs) bridge the gap between general-purpose microprocessors and dedicated hardware, offering:</p><ul><li>Maximum performance</li><li>Minimal power consumption</li><li>Programmability</li></ul><p>The core steps in ASIP design include:</p><ul><li><strong>Modeling the Instruction Set Architecture (ISA):</strong> Using the nML language to define the processor’s structure.</li><li><strong>Automatic Software Development Kit (SDK) Generation:</strong> Produces a C compiler and related tools.</li><li><strong>Algorithm-Driven Architectural Exploration:</strong> Utilizes a “Compile-in-the-Loop” approach to optimize the architecture.</li><li><strong>Automatic Synthesizable RTL Generation:</strong> Employs a “Synthesis-in-the-Loop” methodology for hardware implementation.</li></ul><p><img src="/image/img_asip_design/intro_asip_design_overview.png" alt="ASIP Design Overview"></p><h2 id="Processor-Modeling"><a href="#Processor-Modeling" class="headerlink" title="Processor Modeling"></a>Processor Modeling</h2><h3 id="Header-File"><a href="#Header-File" class="headerlink" title="Header File"></a>Header File</h3><p>The core header file, <code>&lt;processor&gt;.h</code>, defines primitive functions and data types within a dedicated namespace: <code>namespace &lt;processor&gt;_primitive &#123;&#125;</code>. It should include:</p><ul><li>Primitive data type definitions</li><li>Primitive function declarations</li><li>Primitive data type conversion rules</li></ul><p>Additional header files, such as <code>&lt;processor&gt;_&lt;function&gt;.h</code>, can be created to extend functionality with more operations or features.</p><h3 id="nML-Language"><a href="#nML-Language" class="headerlink" title="nML Language"></a>nML Language</h3><p>The nML language defines the structural skeleton and instruction-set architecture of the processor. Key components include:</p><ul><li><code>mem</code>: Defines memory spaces.</li><li><code>reg</code>: Specifies register structures.</li><li><code>pipe</code>: Stores values across pipeline stages (persistent).</li><li><code>trn</code>: Holds temporary values within a single stage.</li><li><code>opn</code>: Represents operation nodes.</li><li><code>cst</code>: Declares type conversion rules.</li><li><code>action</code>: Defines instruction behavior.</li><li><code>image</code>: Specifies binary encoding for instructions.</li><li><code>syntax</code>: Defines the assembly code representation.</li></ul><p>Example nML code:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">opn alu_inst (op:opcode, x:c2u, y:c2u, val:c16s) &#123;</span><br><span class="line">  action &#123;</span><br><span class="line">    stage EX1:</span><br><span class="line">    A = R[x];</span><br><span class="line">    B = val;</span><br><span class="line">    switch (op) &#123;</span><br><span class="line">      case add: C = add(A, B) @alu;</span><br><span class="line">      case sub: C = sub(A, B) @alu;</span><br><span class="line">      case and: C = band(A, B) @alu;</span><br><span class="line">      case or:  C = bor(A, B) @alu;</span><br><span class="line">    &#125;</span><br><span class="line">    stage EX2:</span><br><span class="line">    R[y] = C;</span><br><span class="line">  &#125;</span><br><span class="line">  syntax: op &quot; R&quot; y &quot;, R&quot; x &quot;, &quot; val; # Displays as &lt;add R1, R2, val&gt;</span><br><span class="line">  image: &quot;0&quot;::op::x::y::val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Primitive-Definitions"><a href="#Primitive-Definitions" class="headerlink" title="Primitive Definitions"></a>Primitive Definitions</h3><p>Primitive definitions, written in <code>&lt;processor&gt;.p</code> files, use the Primitive Definition Language (PDG), which is based on C and supports operators, conditions, iterations, and functions with fixed types. PDG definitions are convertible to C++, VHDL, or Verilog.</p><p>Example PDG code:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">word add(word a, word b, astat&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">  int17_t aa = (uint16_t)a; // Zero extension</span><br><span class="line">  int17_t bb = (uint16_t)b;</span><br><span class="line">  int17_t d = aa + bb;</span><br><span class="line">  s = (d[16]^d[15]) :: (d &lt; 0) :: (d == 0);</span><br><span class="line">  return d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ASIP-Designer-Tool-Features"><a href="#ASIP-Designer-Tool-Features" class="headerlink" title="ASIP Designer Tool Features"></a>ASIP Designer Tool Features</h2><h3 id="ChessDE"><a href="#ChessDE" class="headerlink" title="ChessDE"></a>ChessDE</h3><p>The ChessDE tool, typically run on Linux via command line, offers:</p><ul><li>Configuration management</li><li>Function-level incremental compilation</li><li>Parallel compilation on multi-core hosts</li></ul><p>For Instruction Set Simulator (ISS) development, it supports:</p><ul><li>Bit-true, cycle-accurate, or instruction-accurate simulation</li><li>Just-in-time compilation</li><li>Performance and speed profiling</li><li>Automatic verification</li></ul><h1 id="Primitives"><a href="#Primitives" class="headerlink" title="Primitives"></a>Primitives</h1><h2 id="Declaring-Primitives"><a href="#Declaring-Primitives" class="headerlink" title="Declaring Primitives"></a>Declaring Primitives</h2><p>Primitive types are defined using C++-style class declarations within a namespace, formatted as <code>class &lt;type&gt; property(format)</code>. Example:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> tinycore2_primitive &#123;</span><br><span class="line">  <span class="function"><span class="keyword">class</span> word <span class="title">property</span><span class="params">(<span class="number">16</span> bit <span class="type">signed</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">class</span> pmtype <span class="title">property</span><span class="params">(<span class="number">13</span> bit <span class="type">unsigned</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">class</span> sbyte <span class="title">property</span><span class="params">(<span class="number">8</span> bit <span class="type">signed</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Primitive functions represent user-defined behaviors and are categorized into:</p><ul><li><strong>Named Functions:</strong> Standard function declarations.</li><li><strong>Conversion Constructors:</strong> Handle type conversions, such as numbers or vectors.</li></ul><p>Example conversion:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sint8</span>(sin8)    <span class="comment">// xxxxxxxx -&gt; ssssssssxxxxxxxx</span></span><br><span class="line"><span class="built_in">vword3</span>(vbyte3) <span class="comment">// __ef __10 __ab -&gt; ffef 0010 ffab</span></span><br></pre></td></tr></table></figure><p>Example primitive function declaration:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> mycore_primitive &#123;</span><br><span class="line">  <span class="function"><span class="keyword">class</span> stat <span class="title">property</span><span class="params">(<span class="number">3</span> bit <span class="type">unsigned</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">word <span class="title">sub</span><span class="params">(word, word)</span></span>;</span><br><span class="line">  <span class="function">word <span class="title">sub</span><span class="params">(word, word, stat&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">word</span> &#123;</span><br><span class="line">    <span class="built_in">word</span>(sbyte);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Primitive-Definitions-1"><a href="#Primitive-Definitions-1" class="headerlink" title="Primitive Definitions"></a>Primitive Definitions</h2><p>Primitive definitions, written in PDG (based on C), exclude control flow primitives and type conversions. PDG supports C-like operations and control flows. Example:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int16_t</span> INT16_MAX = <span class="number">0x7fff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int16_t</span> INT16_MIN = <span class="number">-0x8000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">word <span class="title">sat16</span><span class="params">(<span class="type">int17_t</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a &gt; INT16_MAX)</span><br><span class="line">    <span class="keyword">return</span> INT16_MAX;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (a &lt; INT16_MIN)</span><br><span class="line">    <span class="keyword">return</span> INT16_MIN;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">word <span class="title">adds</span><span class="params">(word a, word b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int17_t</span> sum = (<span class="type">int17_t</span>)a + (<span class="type">int17_t</span>)b;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sat16</span>(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The PDG tool structure is illustrated below:<br><img src="/image/img_asip_design/PDG_tool.png" alt="PDG Tool Structure"></p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>Primitives consist of data types and functions, organized into:</p><ul><li><strong>Declaration:</strong> Defined in <code>&lt;processor&gt;.h</code></li><li><strong>Definition:</strong> Implemented in <code>&lt;processor&gt;.p</code></li></ul><p>These files collectively enable the modeling, simulation, and synthesis of ASIP designs using the ASIP Designer Tool.</p><h1 id="nML"><a href="#nML" class="headerlink" title="nML"></a>nML</h1><p>In this session, we provides a concise and structured overview of the nML (nested Machine Language) processor description language used for retargeting ASIP Designer tools. nML enables a unified model of processor architecture, capturing instruction behavior, resource connectivity, and hierarchical rules in a single description.</p><h2 id="Key-Features"><a href="#Key-Features" class="headerlink" title="Key Features"></a>Key Features</h2><ul><li><strong>Hierarchical</strong>: The ISA is defined as a hierarchy of rules, allowing modular and composable instruction definitions.</li><li><strong>Structural</strong>: Processor resources (registers, memories, transitories) and their interconnections are explicitly modeled, facilitating clear design and analysis.</li><li><strong>RT-Level</strong>: Instruction behavior is described in terms of register-transfer (RT) operations, capturing the flow of data between storage elements.</li></ul><p>nML integrates datapath descriptions, instruction-set encodings, and RT behavior in one language, simplifying retargeting and tool support.</p><hr><h2 id="Structural-Skeleton"><a href="#Structural-Skeleton" class="headerlink" title="Structural Skeleton"></a>Structural Skeleton</h2><h3 id="Registers"><a href="#Registers" class="headerlink" title="Registers"></a>Registers</h3><p>Registers are declared using:</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Register file</span></span><br><span class="line"><span class="keyword">reg</span> name[size] &lt;data_type, addr_type&gt;;</span><br><span class="line"><span class="comment">// Single register</span></span><br><span class="line"><span class="keyword">reg</span> name&lt;data_type&gt;;</span><br></pre></td></tr></table></figure><ul><li><p><strong>Aliases</strong>: Slice a register file into smaller files or individual registers:</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> R[<span class="number">8</span>]&lt;word,b3u&gt;;</span><br><span class="line"><span class="keyword">reg</span> S[<span class="number">4</span>]&lt;word,b2u&gt; <span class="keyword">alias</span> R[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">reg</span> T[<span class="number">2</span>]&lt;word,b1u&gt; <span class="keyword">alias</span> R[<span class="number">6</span>];</span><br><span class="line"><span class="keyword">reg</span> sp&lt;word&gt;      <span class="keyword">alias</span> S[<span class="number">0</span>];</span><br></pre></td></tr></table></figure></li><li><p><strong>Record Aliases</strong>: Combine consecutive fields of a register file into a wider view:</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> R[<span class="number">8</span>]&lt;word,b3u&gt;;</span><br><span class="line"><span class="keyword">reg</span> L[<span class="number">4</span>]&lt;longword,b2u&gt; <span class="keyword">alias</span> R;  <span class="comment">// 2-word record alias</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Record Structures</strong>: Merge narrow storages into a single wide register:</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> R[<span class="number">8</span>]&lt;word,b3u&gt;;</span><br><span class="line"><span class="keyword">reg</span> S[<span class="number">8</span>]&lt;<span class="keyword">byte</span>,b3u&gt;;</span><br><span class="line"><span class="keyword">reg</span> T[<span class="number">8</span>]&lt;w24,b3u&gt; &#123; R; S; &#125;;</span><br></pre></td></tr></table></figure></li></ul><div align="center">  <img src="/image/img_asip_design/reg_range_alias.png" alt="Register Range Aliases" height="120"/>  <img src="/image/img_asip_design/reg_record_alias.png" alt="Register Record Alias" height="120"/>  <img src="/image/img_asip_design/reg_record_stru.png" alt="Register Record Structure" height="120"/></div><h3 id="Memories"><a href="#Memories" class="headerlink" title="Memories"></a>Memories</h3><p>Memories are static storage elements whose values persist until written.</p><ul><li><p><strong>Declaration</strong>:</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Simple memory declaration</span></span><br><span class="line">mem name[size, step_opt] &lt;data_type, addr_type&gt;;</span><br><span class="line">mem name[from.<span class="variable">.to</span>, step_opt] &lt;data_type, addr_type&gt;;</span><br></pre></td></tr></table></figure><p><strong>Examples</strong>:</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mem PM[dmSize]           &lt;pmtype, word&gt; read(pmLdBus);</span><br><span class="line">mem DM[dmSize]           &lt;word, word&gt; read(dmLdBus) write(dmStBus);</span><br></pre></td></tr></table></figure></li><li><p><strong>Explicit Interface</strong>:</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mem DM[dmSize]&lt;word, word&gt; access &#123;</span><br><span class="line">  ld_dm: dmLdBus‘<span class="number">1</span>‘ = DM[dmAddr];</span><br><span class="line">  st_dm: DM[dmAddr] = dmStBus;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Timing can be annotated absolutely (by stage name) or relatively:</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Absolute</span></span><br><span class="line">dmLdBus‘EX‘ = DM[dmAddr`ID`]`EX`;</span><br><span class="line"><span class="comment">// Relative</span></span><br><span class="line">dmLdBus‘<span class="number">1</span>‘  = DM[dmAddr]`<span class="number">1</span>`;</span><br></pre></td></tr></table></figure></li><li><p><strong>Memory Record Aliases</strong>: Map consecutive memory fields into wider views.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Aligned accesses</span></span><br><span class="line">mem bDM[<span class="number">1024</span>,<span class="number">1</span>]&lt;<span class="keyword">byte</span>,addr&gt;;</span><br><span class="line">mem wDM[<span class="number">1024</span>,<span class="number">2</span>]&lt;word,addr&gt; <span class="keyword">alias</span> bDM;</span><br><span class="line">mem lDM[<span class="number">1024</span>,<span class="number">4</span>]&lt;longword,addr&gt; <span class="keyword">alias</span> bDM;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unaligned accesses</span></span><br><span class="line">mem bDM[<span class="number">1024</span>,<span class="number">1</span>]&lt;<span class="keyword">byte</span>,addr&gt;;</span><br><span class="line">mem wDMu[<span class="number">0</span>.<span class="variable">.1022</span>,<span class="number">1</span>]&lt;word,addr&gt; <span class="keyword">alias</span> bDM align <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li></ul><div align="center">  <img src="/image/img_asip_design/mem_interface.png" alt="Memory Interface" height="140"/>  <img src="/image/img_asip_design/mem_align.png" alt="Memory Mapping Strategies" height="140"/></div><h3 id="Transitories-and-Pipeline-Registers"><a href="#Transitories-and-Pipeline-Registers" class="headerlink" title="Transitories and Pipeline Registers"></a>Transitories and Pipeline Registers</h3><ul><li><p><strong>Transitories</strong> lose their value before the end of a clock cycle and must be read in the same stage they are written:</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">trn Xbus&lt;word&gt;;</span><br><span class="line">trn Ybus&lt;word&gt;;</span><br><span class="line">trn XYbus&lt;longword&gt; &#123; Xbus; Ybus; &#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>Pipeline Registers</strong> function like transitories but pass values to the next stage:</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipe pA&lt;word&gt;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Enumeration-Types-and-Constants"><a href="#Enumeration-Types-and-Constants" class="headerlink" title="Enumeration Types and Constants"></a>Enumeration Types and Constants</h3><ul><li><p><strong>Enums</strong>:</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> alu_op  &#123; ADD <span class="string">&quot;+&quot;</span>, SUB <span class="string">&quot;-&quot;</span>, AND <span class="string">&quot;&amp;&quot;</span>, OR <span class="string">&quot;|&quot;</span> &#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>Constants</strong>:</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def size = <span class="number">2</span>**<span class="number">16</span>;</span><br><span class="line">mem DM[size]&lt;num,addr&gt;;</span><br><span class="line"></span><br><span class="line">cst c_byte&lt;<span class="keyword">byte</span>&gt;;</span><br><span class="line">cst c_3u  &lt;threebitsu&gt;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Processor-Properties"><a href="#Processor-Properties" class="headerlink" title="Processor Properties"></a>Processor Properties</h3><p>Properties identify elements with special processor-level meaning:</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">properties &#123;</span><br><span class="line">  program_memory   : PM;</span><br><span class="line">  program_counter  : PC;</span><br><span class="line">  endianness       : little;</span><br><span class="line">  decode_stage     : ID;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> unconnected : REGX;</span><br></pre></td></tr></table></figure><hr><h2 id="Instruction-Set-Definition"><a href="#Instruction-Set-Definition" class="headerlink" title="Instruction Set Definition"></a>Instruction Set Definition</h2><h3 id="OR-Rules"><a href="#OR-Rules" class="headerlink" title="OR Rules"></a>OR Rules</h3><p>Define alternatives for instruction parts:</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">opn tinycore2 (alu_opn | compare_opn | ... | generate_byte) &#123;</span><br><span class="line">  image: <span class="string">&quot;000000&quot;</span>::alu_opn</span><br><span class="line">       | <span class="string">&quot;000001&quot;</span>::compare_opn</span><br><span class="line">       | ...</span><br><span class="line">       | <span class="string">&quot;100&quot;</span>::generate_byte;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AND-Rules"><a href="#AND-Rules" class="headerlink" title="AND Rules"></a>AND Rules</h3><p>Compose instruction fields orthogonally. Include:</p><ul><li><strong>Action</strong> (RT behavior)</li><li><strong>Syntax</strong> (assembly representation)</li><li><strong>Image</strong> (binary encoding)</li></ul><p><strong>Example</strong>:</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">opn alu_opn (op: alu_op, a: eR, b: eR) &#123;</span><br><span class="line">  action &#123;</span><br><span class="line">    operandA = R[a];</span><br><span class="line">    operandB = R[b];</span><br><span class="line">    aluC    = (op == ADD) ? add(operandA, operandB)</span><br><span class="line">             : (op == SUB) ? sub(operandA, operandB)</span><br><span class="line">             : (op == AND) ? band(operandA, operandB)</span><br><span class="line">             : bor(operandA, operandB);</span><br><span class="line">    R[a]    = aluC;</span><br><span class="line">  &#125;</span><br><span class="line">  syntax: a <span class="string">&quot; = &quot;</span> a op b;</span><br><span class="line">  image : op::a::b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Parallel Composition</strong>:</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">opn alu_load (op: alu_opn, ld: load_indirect) &#123;</span><br><span class="line">  action &#123; op; ld; &#125;</span><br><span class="line">  syntax: op <span class="string">&quot; || &quot;</span> ld;</span><br><span class="line">  image : op::ld;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Pipelines-and-Hazards"><a href="#Pipelines-and-Hazards" class="headerlink" title="Pipelines and Hazards"></a>Pipelines and Hazards</h2><h3 id="Describing-Pipelines"><a href="#Describing-Pipelines" class="headerlink" title="Describing Pipelines"></a>Describing Pipelines</h3><ol><li>Declare pipeline registers (<code>pipe</code>).</li><li>Define stages and nested scopes.</li><li>Annotate storage accesses with stage information.</li></ol><p><strong>Example</strong> (multi-accumulate operation):</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> stages &#123; IF, ID, RD, E1, E2 &#125;;</span><br><span class="line"></span><br><span class="line">pipe mA&lt;word&gt;;</span><br><span class="line">pipe mB&lt;word&gt;;</span><br><span class="line"><span class="keyword">reg</span>  ACC&lt;longword&gt; read(ta) write(tb);</span><br><span class="line"></span><br><span class="line">opn macc_opn (op: mult_add_sub, a: eR, b: eR) &#123;</span><br><span class="line">  action &#123;</span><br><span class="line">    stage RD:</span><br><span class="line">      mA = R[a]; mB = R[b];</span><br><span class="line">    stage E1.<span class="variable">.E2</span>:</span><br><span class="line">      tb`E2` = (op == mult_add)</span><br><span class="line">              ? mult_add(ta`E2`, mA`E1`, mB`E1`)</span><br><span class="line">              : mult_sub(ta`E2`, mA`E1`, mB`E1`);</span><br><span class="line">    stage E2:</span><br><span class="line">      ACC = tb;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Pipeline-Hazards"><a href="#Pipeline-Hazards" class="headerlink" title="Pipeline Hazards"></a>Pipeline Hazards</h3><ul><li><p><strong>Control Hazards</strong>: Use <code>cycles(n)</code> or <code>delay_slots(n)</code> to model jump delays.</p></li><li><p><strong>Data &amp; Structural Hazards</strong>:</p><ul><li>Softwall stalls (insert NOPs)</li><li>Hardware stalls</li><li>Bypassing (forwarding)</li></ul></li></ul><p>For detailed hazard mitigation strategies, refer to the <a href="https://en.wikipedia.org/wiki/Hazard_%28computer_architecture%29">Hazard (computer architecture) Wiki</a>.</p><hr><h2 id="Mode-Rules"><a href="#Mode-Rules" class="headerlink" title="Mode Rules"></a>Mode Rules</h2><p>Define how storage locations are addressed.</p><h3 id="Register-Mode"><a href="#Register-Mode" class="headerlink" title="Register Mode"></a>Register Mode</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mode mR (e: eR) &#123;</span><br><span class="line">  value : R[e];</span><br><span class="line">  syntax: e;</span><br><span class="line">  image : e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Memory-Mode"><a href="#Memory-Mode" class="headerlink" title="Memory Mode"></a>Memory Mode</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mode ind_ld_st (a: eR) &#123;</span><br><span class="line">  value  : DM[dmAddr = R[a]];</span><br><span class="line">  action : R[a] = add(R[a], <span class="number">1</span>);</span><br><span class="line">  syntax : <span class="string">&quot;DM[&quot;</span> a <span class="string">&quot;+&quot;</span>]<span class="string">&quot;;</span></span><br><span class="line"><span class="string">  image  : a;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><hr><h2 id="Image-Attributes"><a href="#Image-Attributes" class="headerlink" title="Image Attributes"></a>Image Attributes</h2><p>Define binary encodings:</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">opn arith_instr (alu_instr | as_sh_instr | shift_instr | macc_rnd_nop_instr) &#123;</span><br><span class="line">  image: <span class="string">&quot;00&quot;</span>::alu_instr</span><br><span class="line">       | <span class="string">&quot;01&quot;</span>::as_sh_instr</span><br><span class="line">       | <span class="string">&quot;10&quot;</span>::shift_instr</span><br><span class="line">       | <span class="string">&quot;11&quot;</span>::macc_rnd_nop_instr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Use <code>complete_image</code> when orthogonality of fields must be enforced.</p><h1 id="PAG-Modules"><a href="#PAG-Modules" class="headerlink" title="PAG Modules"></a>PAG Modules</h1><h2 id="Modeling-the-Processor-Control-Unit"><a href="#Modeling-the-Processor-Control-Unit" class="headerlink" title="Modeling the Processor Control Unit"></a>Modeling the Processor Control Unit</h2><p><img src="/image/img_asip_design/PCU_overview" alt="overview of PCU"></p><h3 id="File-Structure"><a href="#File-Structure" class="headerlink" title="File Structure"></a>File Structure</h3><p>The PCU is modeling using PDG code. The model is located in the <code>&lt;processor&gt;_pcu.p</code> and the file should contain:</p><ul><li>PCU Specific storage and nML storage. They should be look like:<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pcu_storages &#123;</span><br><span class="line">  <span class="keyword">reg</span> reg_booting&lt;uint2_t&gt;;</span><br><span class="line">  trn pc_step&lt;addr&gt;;</span><br><span class="line">&#125;</span><br><span class="line">hw_init reg_booting = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li>Auxiliary Function.</li><li>A <code>user_issue()</code> funciton.</li><li>A <code>user_next_pc()</code> function.</li></ul><h3 id="Fetching-and-Issuing-Instruction"><a href="#Fetching-and-Issuing-Instruction" class="headerlink" title="Fetching and Issuing Instruction"></a>Fetching and Issuing Instruction</h3><p>In fetching stage, it should be done pipelined. In prefetch stage, address is sent to PM, and in fetch stage, instruction is available on PM read out. </p><figure class="highlight v"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PF</span></span><br><span class="line">pm_read`<span class="number">1</span>` = PM[pm_addr `<span class="number">0</span>` = nextpc] `<span class="number">0</span>`;</span><br><span class="line"><span class="comment">//IF</span></span><br><span class="line">pmtype f_instr = pm_read;</span><br></pre></td></tr></table></figure><p>After fetching instructions successfully, we need to issue instructions, which is the act of sending a fetched instruction into the processor pipeline for decoding and execution. <code>issue_sig()</code> returns zero during N-1 cycles after issuing of a multi-cycle intruction. On processors with multi-cycle instruction <code>issure_sig()</code> is tested before the next instruction can be issued.  </p><h3 id="Updating-the-PC"><a href="#Updating-the-PC" class="headerlink" title="Updating the PC"></a>Updating the PC</h3><h4 id="Straight-Line-Code"><a href="#Straight-Line-Code" class="headerlink" title="Straight Line Code"></a>Straight Line Code</h4><p>Straight line code: increment the PC. The nML and PDG code is closely coorperate, which shows as :</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tinycore2.n</span></span><br><span class="line"><span class="keyword">reg</span> PC&lt;word&gt; read (pc_r) write (pc_w)</span><br><span class="line"></span><br><span class="line"><span class="comment">// tinycore2_pcu.p</span></span><br><span class="line"><span class="keyword">void</span> tinycore2::user_next_pc()</span><br><span class="line">&#123;</span><br><span class="line">  pc_r = PC;</span><br><span class="line">  word nextpc;</span><br><span class="line">  <span class="keyword">if</span> <span class="comment">// Treat control flow instructions</span></span><br><span class="line">    nextpc = ...;</span><br><span class="line">  <span class="keyword">else</span> <span class="comment">// Increment PC</span></span><br><span class="line">    nextpc = pc_r + <span class="number">1</span>;</span><br><span class="line">  PC = pc_w = nextpc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Un-conditional-Jump"><a href="#Un-conditional-Jump" class="headerlink" title="Un&amp;conditional Jump"></a>Un&amp;conditional Jump</h4><p>The different between these two jumps are been detailed defined in nML files. In processor header file, they can be present as :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">jumpi</span><span class="params">(sbyte)</span> <span class="title">property</span><span class="params">(relative jump)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">jumpci</span><span class="params">(<span class="type">bool</span>,sbyte)</span> <span class="title">property</span><span class="params">(relative jump)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="Subroutine"><a href="#Subroutine" class="headerlink" title="Subroutine"></a>Subroutine</h4><p>For the processor, it should contain the<br>subtoutine call and return. They can save and retrieve the return address to the link register. This help construct the correct pipeline control (due to <code>delay_slot(n)</code>). They have the header file like:</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">word <span class="title function_">bsr</span><span class="params">(word)</span> <span class="title function_">property</span><span class="params">(abusolute call)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">rst</span><span class="params">(word)</span> <span class="title function_">property</span><span class="params">(ret)</span>;</span><br></pre></td></tr></table></figure><p>and the corresponding model shows as:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lnk_pf = (pc_r = PC) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (jump_pc_trgt_sig|| ...)</span><br><span class="line">    nextpc = pc_trgt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (jump_pc_trgt_sig|| ...)</span><br><span class="line">    nextpc = pc_trgt;</span><br></pre></td></tr></table></figure><h4 id="Booting-Process"><a href="#Booting-Process" class="headerlink" title="Booting Process"></a>Booting Process</h4><p>The booting process contains three states: reset, boot, run. In reset, we avoid PM fetch. In boot state, it refers to the first cycle after reset. In run state, it refer to the subsequent cycles</p><p><img src="/image/img_asip_design/pcu_booting.png" alt="pcu_booting"></p><h3 id="Tinycore2-PCU-Model"><a href="#Tinycore2-PCU-Model" class="headerlink" title="Tinycore2 PCU Model"></a>Tinycore2 PCU Model</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">pcu_storages &#123;</span><br><span class="line">    reg reg_booting&lt;<span class="type">uint2_t</span>&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hw_init reg_booting = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tinycore2::user_issue</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Get instruction on PM output bus </span></span><br><span class="line">  <span class="comment">// (from PM fetch issued previous cycle)</span></span><br><span class="line">  pmtype f_instr = pmLdBus;</span><br><span class="line">  <span class="comment">// Issue instruction</span></span><br><span class="line">  <span class="keyword">if</span> (reg_booting == <span class="number">0</span>) <span class="comment">// Run state</span></span><br><span class="line">      issue_instr(pc_r = PC,<span class="number">1</span>,f_instr); </span><br><span class="line">  <span class="comment">// Exit from booting state</span></span><br><span class="line">  reg_booting = reg_booting &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tinycore2::user_next_pc</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Set link address</span></span><br><span class="line">  lnk_pf = (pc_r = PC) + <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// Calculate next PC</span></span><br><span class="line">  word nextpc=<span class="number">0</span>;</span><br><span class="line">  <span class="type">bool</span> fetch = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (reg_booting == <span class="number">2</span>)</span><br><span class="line">      fetch = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (reg_booting == <span class="number">1</span>)</span><br><span class="line">      fetch = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (jump_pc_offs_sig) <span class="comment">// relative jump </span></span><br><span class="line">      nextpc = pc_r + pc_offs;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (jump_pc_trgt_sig) <span class="comment">// absolute jump </span></span><br><span class="line">      nextpc = pc_trgt;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (loop_test()) <span class="comment">// jump to loop start</span></span><br><span class="line">      nextpc = ls_r = LS;</span><br><span class="line">  <span class="keyword">else</span> <span class="comment">// increment PC </span></span><br><span class="line">      nextpc = pc_r + <span class="number">1</span>;</span><br><span class="line">  PC = pc_w = nextpc;</span><br><span class="line">  <span class="comment">// Issue PM fetch</span></span><br><span class="line">  <span class="keyword">if</span> (fetch)</span><br><span class="line">      pmLdBus `<span class="number">1</span>` = PM[pmAddr `<span class="number">0</span>` = nextpc] `<span class="number">1</span>`;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Manipulating-the-Pipeline"><a href="#Manipulating-the-Pipeline" class="headerlink" title="Manipulating the Pipeline"></a>Manipulating the Pipeline</h3><ul><li>Hardware stalls: During the stall stages, PCU must not issue a new information and typically not fetch a new instruction. It will be show as <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hw_stall <span class="number">1.</span>.<span class="number">2</span> cycles &#123;</span><br><span class="line">  stage E3:</span><br><span class="line">    R[#] = ...;</span><br><span class="line">&#125; -&gt; &#123;</span><br><span class="line">  stage E1:</span><br><span class="line">    ... = R[#];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Killing instructions: <code>if (&lt;cnd&gt;) kill_instr(ID);</code></li><li>Stalling the instruction pipeline if (<cnd>) stall_instr(E1);</li></ul><h2 id="Modeling-Multi-Cycle-Functional-Units"><a href="#Modeling-Multi-Cycle-Functional-Units" class="headerlink" title="Modeling Multi-Cycle Functional Units"></a>Modeling Multi-Cycle Functional Units</h2><h3 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"></a>Introduction</h3><p>MCFUs execute multi-cycle operations with ioterative nature. They are seperatie module in the design with local control. The MCF model have primitive function with multicycle property. It starts an operation that is modelled as nML action, then be modelled as a PDG module. Hardware stall rules will be added to  synchronis the MCFU with instructions that are execute on the pipeline.</p><h3 id="Example-non-restoring-iterative-division"><a href="#Example-non-restoring-iterative-division" class="headerlink" title="Example: non-restoring iterative division"></a>Example: non-restoring iterative division</h3><p>The basic iterative algorithm:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MQ = &lt;numerator&gt;; <span class="comment">// MQ is same as M::Q</span></span><br><span class="line">B = &lt;denominator&gt;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> cnt = <span class="number">0</span>; cnt &lt; <span class="number">16</span>; cnt++) &#123;</span><br><span class="line">    <span class="comment">// division step</span></span><br><span class="line">    MQ = MQ &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (M - B &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        M = M - B;</span><br><span class="line">        Q[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In this case, the multi-cycle function unit contains:</p><ul><li>Accesses processor register MQ</li><li>Has local register B and cnt</li><li>Implements division step and counts iterations</li></ul><p><img src="/image/img_asip_design/mcfu_division.png" alt="mcfu division part"></p><h4 id="primitive-function"><a href="#primitive-function" class="headerlink" title="primitive function"></a>primitive function</h4><p>declared in the primitive header file:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a = b * q + r</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">divide</span><span class="params">(word a, word b, word&amp; q, word&amp; r)</span> <span class="title function_">property</span><span class="params">(multicycle_16)</span>;</span><br></pre></td></tr></table></figure><h4 id="nML-action"><a href="#nML-action" class="headerlink" title="nML action"></a>nML action</h4><p>The action specifies interface(operand and registers) for compiler. The outputs Q and M are not written as result of nML action, but will be written in PDG of mu;ti-cycle unit.</p><figure class="highlight v"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> R[<span class="number">8</span>]&lt;word,uint3&gt; read(ta tb); <span class="comment">// operand register</span></span><br><span class="line"><span class="keyword">reg</span> Q&lt;word&gt; <span class="keyword">alias</span> R[<span class="number">6</span>] read(qr) write(qw); <span class="comment">// quotient register</span></span><br><span class="line"><span class="keyword">reg</span> M&lt;word&gt; <span class="keyword">alias</span> R[<span class="number">7</span>] read(mr) write(mw); <span class="comment">// remainder register</span></span><br><span class="line"></span><br><span class="line">opn divide (a : c_3, b : c_3)</span><br><span class="line">&#123;</span><br><span class="line">    action &#123;</span><br><span class="line">        stage EX: divide(ta = R[a], tb = R[b], Q = qw, M = mw);</span><br><span class="line">    &#125;</span><br><span class="line">    image : a, b, cycles(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The PDG module contain local registers, function process(), initial call to process() and subsequent calls to process(). M and Q are written be div unit. Busy signal for use in stall rules.</p><figure class="highlight v"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">uint32_t divide_step(uint32_t mq, uint16_t b)</span><br><span class="line"></span><br><span class="line">multicycle_fu div &#123;</span><br><span class="line">  <span class="keyword">reg</span> B&lt;uint16&gt; ; <span class="comment">// denominator register</span></span><br><span class="line">  <span class="keyword">reg</span> Cnt&lt;uint5_t&gt;; <span class="comment">// counter</span></span><br><span class="line">  <span class="keyword">void</span> process() &#123; </span><br><span class="line">    uint5_t new_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (vd_divide_ta_tb_qw_mw_EX_sig) &#123;</span><br><span class="line">      Q = qw = ta; </span><br><span class="line">      ...;</span><br><span class="line">      new_cnt = <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Cnt != <span class="number">0</span>) &#123;</span><br><span class="line">      mq = divide_step((mr=M)::(qr=Q),B);</span><br><span class="line">      M = mw = mq[<span class="number">31</span>:<span class="number">16</span>];</span><br><span class="line">      Q = qw = mq[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">      new_cnt = Cnt - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Cnt = new_cnt;</span><br><span class="line">    div_busy = new_cnt != <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Modeling-IO-interfaces"><a href="#Modeling-IO-interfaces" class="headerlink" title="Modeling IO interfaces"></a>Modeling IO interfaces</h2><p>In nML, the properties of memories are abstracted(data type, address type, ports, timing). The actual memories have more implementation related properties. IO interfaces define such interfaces between the nML model and the actual implementation. They are modeled as PDG modules. </p><p><img src="/image/img_asip_design/io_interface.png" alt="io_interface"></p><p>The overall structure has following header:</p><ul><li>Module header: define interface unit <code>bypass_dm</code> and its related nML memory <code>DM</code></li><li>External interface: local mem declaration <code>eDM</code> defines the external interface and additional inport and outports and allowed</li><li>The local storages contains registers to store state and transitories to copy data between functions.<figure class="highlight v"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">io_interface bypass_dm (DM)&#123;</span><br><span class="line"><span class="comment">// external interface </span></span><br><span class="line">  mem eDM[<span class="number">2</span>**<span class="number">16</span>] &lt;word,addr&gt; access &#123;</span><br><span class="line">    ld_edm: edm_rd`<span class="number">1</span>` = eDM[edm_ad];</span><br><span class="line">    st_edm: eDM[edm_ad] = edm_wr;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// local storages</span></span><br><span class="line">  <span class="keyword">reg</span> st_ff&lt;uint1_t&gt;; </span><br><span class="line">  <span class="keyword">reg</span> ad_ff&lt;addr&gt;;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Process functions: one or more process funcitons defining the  behavior of the IO interface. There are two main process behavior: <code>process_request()</code> and <code>process_result()</code>. Having multiple process functions helps to reduce delta cycles in the ISS.<figure class="highlight v"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">io_interface bypass_dm (DM)&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// process functions</span></span><br><span class="line">  process process_result() &#123;</span><br><span class="line">    dm_rd = (match_ff) ? data_ff</span><br><span class="line">    ... </span><br><span class="line">  &#125;</span><br><span class="line">  process process_request() &#123;</span><br><span class="line">    ... </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Debug Access Functions: used by simulator to initialize memories and display the content of memories.</li></ul><h3 id="Memory-bypass-Example"><a href="#Memory-bypass-Example" class="headerlink" title="Memory bypass Example"></a>Memory bypass Example</h3><p>Architecture with ld&#x2F;st timing that is inline with SRAM timing that might encounter structual hazard in address bus ‘ab’ in case of store-load sequence. In nML, we can remove hazard by starting store in <code>IDload</code> and in IO interface we can delay st_dm and ab for a store and buffer store in case of conflict and bypass memory in case of data dependency.</p><figure class="highlight v"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">io_interface bypass_dm ( DM ) &#123;</span><br><span class="line">  mem eDM[<span class="number">2</span>**<span class="number">16</span>]&lt;word,addr&gt; access &#123;</span><br><span class="line">    e_ld: e_db‘<span class="number">1</span>‘ = eDM[e_ab];</span><br><span class="line">    e_st: eDM[e_ab] = e_wb; </span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">reg</span> st_ff&lt;uint1_t&gt;; <span class="comment">// delay store control signal</span></span><br><span class="line">  <span class="keyword">reg</span> addr_ff&lt;addr&gt;; <span class="comment">// delay store address</span></span><br><span class="line">  <span class="keyword">reg</span> data_ff&lt;word&gt;; <span class="comment">// buffer data to be stored</span></span><br><span class="line">  <span class="keyword">reg</span> valid_ff&lt;uint1_t&gt;; <span class="comment">// buffer contains data</span></span><br><span class="line">  <span class="keyword">reg</span> match_ff&lt;uint1_t&gt;; <span class="comment">// load of data in buffer</span></span><br><span class="line"></span><br><span class="line">  process process_result() &#123;</span><br><span class="line">    db = (match_ff) ? data_ff : e_db;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  process process_request() &#123;</span><br><span class="line">    e_ld = <span class="number">0</span>; e_st = <span class="number">0</span>; e_ab = ab; e_wb = wb;</span><br><span class="line">    <span class="keyword">if</span> (ld_dm) &#123;</span><br><span class="line">      bool match = (ab==addr_ff) &amp;&amp; (valid_ff||st_ff);</span><br><span class="line">      e_ld = !match;</span><br><span class="line">      match_ff = match;</span><br><span class="line">      <span class="keyword">if</span> (st_ff) &#123;</span><br><span class="line">        data_ff = wb; <span class="comment">// store and load in same cycle</span></span><br><span class="line">        valid_ff = <span class="number">1</span>; <span class="comment">// data enters buffer</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (valid_ff) &#123; <span class="comment">// empty buffer to memory</span></span><br><span class="line">      e_st = <span class="number">1</span>; e_ab = addr_ff; e_wb = data_ff;</span><br><span class="line">      valid_ff = <span class="number">0</span>; </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (st_ff) &#123; <span class="comment">// normal store</span></span><br><span class="line">        e_st = <span class="number">1</span>; e_ab = addr_ff;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (st_dm) <span class="comment">// delay address of store</span></span><br><span class="line">      addr_ff = ab;</span><br><span class="line">    &#125;</span><br><span class="line">    st_ff = st_dm; <span class="comment">// delay store control</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> dbg_access_DM(<span class="keyword">unsigned</span> a, word&amp; v, bool read) &#123;</span><br><span class="line">    <span class="keyword">if</span> (valid_ff &amp;&amp; addr_ff == a)</span><br><span class="line">      dbg_access_data_ff(v,read);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      dbg_access_eDM(a,v,read);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="Summary-of-MCFU-and-IO-interface"><a href="#Summary-of-MCFU-and-IO-interface" class="headerlink" title="Summary of MCFU and IO interface"></a>Summary of MCFU and IO interface</h2><table><thead><tr><th></th><th><strong>MCFU</strong></th><th><strong>IO Interface</strong></th></tr></thead><tbody><tr><td><strong>Common features</strong></td><td>Module with its own resources</td><td>Module with its own resources</td></tr><tr><td></td><td>Module has internal state</td><td>Module has internal state</td></tr><tr><td></td><td>Module has direct access to nML resources</td><td>Module has direct access to nML resources</td></tr><tr><td><strong>Intended use case</strong></td><td>Implementation of a primitive function</td><td>Implement path from an nML memory definition (as seen by the compiler) to physical memories</td></tr><tr><td><strong>Compiler interface</strong></td><td>Primitives have a compiler interface:<br>• Arguments are connected to registers<br>• Read stages for input arguments<br>• Expected duration (multicycle_N)</td><td>The compiler view is the abstract nML memory access specifier</td></tr><tr><td><strong>Activation</strong></td><td>Control signal generated based on primitive</td><td>Control signal based on load &#x2F; store operations</td></tr><tr><td></td><td>Alternatively user defined transitories can be used</td><td>Alternatively user defined transitories can be used</td></tr><tr><td><strong>Wait cycles</strong></td><td>Default: unit is stalled<br>Overrule with property</td><td>Unit is not stalled<br>Function <code>in_wait_cycle()</code> can be tested to guard some register updates</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Computer Architecture </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASIP design </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Overview of ASIP design tool</title>
      <link href="/2025/07/01/asip_design_tool/Introduction_to_asip_design/"/>
      <url>/2025/07/01/asip_design_tool/Introduction_to_asip_design/</url>
      
        <content type="html"><![CDATA[<h1 id="Overview-of-ASIP-Designer"><a href="#Overview-of-ASIP-Designer" class="headerlink" title="Overview of ASIP Designer"></a>Overview of ASIP Designer</h1><h2 id="What-Is-ASIP-Designer"><a href="#What-Is-ASIP-Designer" class="headerlink" title="What Is ASIP Designer"></a>What Is ASIP Designer</h2><p><strong>ASIP Designer</strong> is Synopsys’s tool for developing Application-Specific Instruction-set Processors (ASIPs). It lets you:</p><ul><li>Define custom processor architectures using <strong>nML</strong>, a high-level description language for ISA, registers, and memory</li><li>Generate software toolchains tailored to your ISA</li><li>Simulate performance and refine your design</li></ul><h2 id="Example-Project-tctcore"><a href="#Example-Project-tctcore" class="headerlink" title="Example Project: tctcore"></a>Example Project: <code>tctcore</code></h2><p>Before starting, set up the environment and load the required modules:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> asip_design/</span><br><span class="line"><span class="built_in">source</span> chess_env_LNa64.sh</span><br><span class="line">module load base</span><br><span class="line">module load asip_designer</span><br><span class="line">module load vcs</span><br></pre></td></tr></table></figure><p>In this example, we use the educational <code>tctcore</code> project to demonstrate the workflow.</p><h3 id="Project-Structure"><a href="#Project-Structure" class="headerlink" title="Project Structure"></a>Project Structure</h3><p><img src="/image/img_asip_design/tctcore_project_structure.png" alt="tctcore Project Structure"></p><h3 id="Generating-the-Simulation-Model"><a href="#Generating-the-Simulation-Model" class="headerlink" title="Generating the Simulation Model"></a>Generating the Simulation Model</h3><p>Run the model generation script:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make_model</span><br></pre></td></tr></table></figure><p>Then compile the C&#x2F;C++ algorithm (e.g., <code>irrdirect</code>) and simulate it:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tctcore_chess.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Low-pass filter parameters:</span></span><br><span class="line"><span class="comment">//   Sample frequency (Hz)              : 44 000</span></span><br><span class="line"><span class="comment">//   Cut-off frequency (Hz)            : 5 000</span></span><br><span class="line"><span class="comment">//   Damping factor                     : 1.5</span></span><br><span class="line"><span class="comment">//   Data width (signed)                : 16 bits</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">1341</span>, b = <span class="number">5591</span>, g = <span class="number">16607</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> C[<span class="number">5</span>] = &#123; a, <span class="number">2</span>*a, a, g, -b &#125;;</span><br><span class="line"><span class="type">int</span> xd[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;, yd[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">low_pass</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">long</span> acc = fmult(x, C[<span class="number">0</span>])</span><br><span class="line">             + fmult(xd[<span class="number">0</span>], C[<span class="number">1</span>])</span><br><span class="line">             + fmult(xd[<span class="number">1</span>], C[<span class="number">2</span>])</span><br><span class="line">             + fmult(yd[<span class="number">0</span>], C[<span class="number">3</span>])</span><br><span class="line">             + fmult(yd[<span class="number">1</span>], C[<span class="number">4</span>]);</span><br><span class="line">    <span class="type">int</span> y = <span class="number">2</span> * (<span class="type">int</span>)round(acc);</span><br><span class="line">    xd[<span class="number">1</span>] = xd[<span class="number">0</span>]; xd[<span class="number">0</span>] = x;</span><br><span class="line">    yd[<span class="number">1</span>] = yd[<span class="number">0</span>]; yd[<span class="number">0</span>] = y;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">low_pass_v2</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">long</span> acc = fmult(x, C[<span class="number">0</span>]);</span><br><span class="line">    acc = fmacc(xd[<span class="number">0</span>], C[<span class="number">1</span>], acc);</span><br><span class="line">    acc = fmacc(xd[<span class="number">1</span>], C[<span class="number">2</span>], acc);</span><br><span class="line">    acc = fmacc(yd[<span class="number">0</span>], C[<span class="number">3</span>], acc);</span><br><span class="line">    acc = fmacc(yd[<span class="number">1</span>], C[<span class="number">4</span>], acc);</span><br><span class="line">    <span class="type">int</span> y = <span class="number">2</span> * (<span class="type">int</span>)round(acc);</span><br><span class="line">    xd[<span class="number">1</span>] = xd[<span class="number">0</span>]; xd[<span class="number">0</span>] = x;</span><br><span class="line">    yd[<span class="number">1</span>] = yd[<span class="number">0</span>]; yd[<span class="number">0</span>] = y;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> <span class="title function_">chess_storage</span><span class="params">(DM:<span class="number">256</span>)</span> input_port;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> <span class="title function_">chess_storage</span><span class="params">(DM:<span class="number">257</span>)</span> output_port;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++)</span><br><span class="line">        output_port = low_pass(input_port);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++)</span><br><span class="line">        output_port = low_pass_v2(input_port);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The code above illustrates two implementations:</p><ol><li><strong><code>low_pass</code></strong> uses basic multiply and add operations.</li><li><strong><code>low_pass_v2</code></strong> leverages the intrinsic <code>fmacc</code> for fused multiply-accumulate.</li></ol><p>Further details on nML structure will follow in subsequent sessions.</p><h2 id="HDL-ISS-and-Libraries"><a href="#HDL-ISS-and-Libraries" class="headerlink" title="HDL, ISS, and Libraries"></a>HDL, ISS, and Libraries</h2><ul><li><strong>HDL</strong>: Generates synthesizable Verilog&#x2F;VHDL from the design.</li><li><strong>ISS</strong>: Provides an instruction-set simulator for software validation.</li><li><strong>Libraries</strong>: Include standard and custom components (e.g., arithmetic units, register files).</li></ul><h2 id="Executing-a-tctcore-Task"><a href="#Executing-a-tctcore-Task" class="headerlink" title="Executing a tctcore Task"></a>Executing a <code>tctcore</code> Task</h2><p>To run prx files and generate infrastructure code, use <code>chessmk</code> and a Makefile. For example:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chessmk lib/tctcore.prx -r</span><br><span class="line">chessmk lib/tctcore.prx</span><br><span class="line">chessmk iss/caiss.prx</span><br><span class="line">chessmk hdl/tctcore_vlog.prx</span><br></pre></td></tr></table></figure><p>This process creates directories for debugging, type&#x2F;register visualization, and centralized maintenance.</p><h3 id="Running-C-C-Simulation"><a href="#Running-C-C-Simulation" class="headerlink" title="Running C&#x2F;C++ Simulation"></a>Running C&#x2F;C++ Simulation</h3><p>Create a dedicated Makefile (e.g., <code>make_tctcore</code>) then:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Compile algorithm</span></span><br><span class="line">chesscc -c iirdirect/iirdirect.c -P lib/tctcore.prx</span><br><span class="line"><span class="comment"># Link to generate executable</span></span><br><span class="line">chesscc -o hdl/tctcore_vlog_go/iirdirectx iirdirect.o -P lib/tctcore.prx</span><br><span class="line"></span><br><span class="line"><span class="comment"># Elaborate and simulate</span></span><br><span class="line"><span class="built_in">cd</span> hdl/tctcore_vlog_go</span><br><span class="line">make elab</span><br><span class="line">make <span class="built_in">test</span> TEST=iirdirectx</span><br><span class="line">make sim</span><br><span class="line"><span class="built_in">cd</span> ../..</span><br></pre></td></tr></table></figure><p>At this point, the basic simulation and verification are complete. Continuous integration into the CI&#x2F;CD pipeline can be configured as needed.</p>]]></content>
      
      
      <categories>
          
          <category> Computer Architecture </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASIP design </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Biography</title>
      <link href="/2025/02/10/aboutMe/"/>
      <url>/2025/02/10/aboutMe/</url>
      
        <content type="html"><![CDATA[<h1 id="Biography"><a href="#Biography" class="headerlink" title="Biography"></a>Biography</h1><p>I am currently a junior at the School of Electronic Engineering and Computer Science at Peking University, where my research interests lie at the intersection of hardware architecture design and machine learning, with a particular focus on hardware-software co-design. This field excites me because it bridges the gap between efficient hardware systems and intelligent algorithms, offering transformative potential for modern computing.</p><p>Building on a strong foundation in hardware design from my undergraduate studies, along with research experience in AI chip development, I am eager to deepen my expertise and contribute to groundbreaking innovations in the field. I plan to continue my graduate studies in the fall of 2026, and I am currently seeking a fall research internship to further develop my skills and knowledge.</p><p>Feel free to reach out to me anytime. You can find my CV <a href="https://worldline22.github.io/pdf/CV.pdf">here</a>.</p>]]></content>
      
      
      <categories>
          
          <category> Introduction </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写在前面（Preface）</title>
      <link href="/2024/07/28/preinfo/"/>
      <url>/2024/07/28/preinfo/</url>
      
        <content type="html"><![CDATA[<ol><li>这是我的个人博客，本网站将不定期更新自己科研、生活上的点点滴滴，希望你能喜欢。</li><li>网页分为“黑&#x2F;白”两种模式可供选择，右下角设置键可以修改模式。</li><li>本网页目前评论功能只支持拥有github账号的访客使用，评论时请使用自己的github账号登录，注意评论文明，感谢你的浏览(❤ ω ❤)。</li></ol><hr><ol><li><p>This is my personal blog. It will be updated from time to time with bits and pieces of my research and daily life. I hope you enjoy it.</p></li><li><p>The website offers both dark and light modes, which you can switch using the settings button at the bottom right corner.</p></li><li><p>Currently, the comment feature only supports visitors with a GitHub account. Please log in with your GitHub account to comment. Be respectful—thank you for visiting! (❤ ω ❤)</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Introduction </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tips </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
